# 백트래킹

일반적으로 그래프/트리의 모든 원소를 완전 탐색하기 위한 목적으로 사용할 수 있다.

> **DFS와의 차이점**
>
> 1. DFS는 일반적으로 완전 탐색 목적으로, 재귀 함수를 이용해 구현
> 2. 백트래킹도 재귀 함수를 이용해 구현하는 것이 일반적이지만, 단순히 완전 탐색하는 것이 아니라 조건에 따라서 **망한 노드**로 이동

## 동작 방식

그래프를 표현하는 2가지 방식

1. 인접 행렬
2. 인접 리스트

## [N-Queen](./n-Queen.js)

- N x N 체스 보드 위에 퀸 N개가 서로 공격할 수 없게 놓는 문제

```
N = 8 이라면

- 64개의 위치에 8개의 퀸을 설치하는 모든 조합의 수는 Combination(64,8)
- 단순히 모든 경우의 수를 전부고려하면 경우의 수가 너무 커지기 때문에 **유망한 경우에만 탐색** => 백트래킹 방식 사용

1. 각 행마다 1개씩의 퀸을 놓는다. (N개의 퀸)
2. 첫 번째 행부터 퀸을 하나씩 놓는다.
   - 8개의 행에 놓을수 있는 퀸의 경우의수 = 2^3을 8번 곱한, 2^24개의 경우
3. 하나의 퀸 A가 이미 존재하는 상태에서, 다른 퀸 B를 놓으려면?
   - 퀸 A의 상하좌우 및 대각선 위치가 아닌 위치에 퀸 B를 놓을 수 있다.
```

- 트리구조를 사용하여 이미 놓아진 퀸 A 상태를 가진채로 퀸 B를 고려한다.

- 가능한 모든 조합의 수를 구하는 것과 같다.
- 매 재귀함수 마다 실제로 N x N 모든 위치를 모두 볼 필요가 없다

맨 처음 행(row)부터 차례대로 퀸을 놓는 다고 생각하면 가짓수를 훨씬 줄일 수 있다.

- N-Queen문제는 가능한 조합을 계산하는 것이므로, **현재 행의 이전행으로 돌아갈 필요가 없다.**

> ##### 백트래킹을 진행할때 경우의 수를 최대한 줄이는 방법.
>
> - **이전까지 놓았던 퀸들과 상충되지 않는 조건**을 만족하는 위치에 대해서만 재귀 함수를 호출
>   1.  재귀 함수를 통해 모든 경우의 수를 다 찾은 뒤, 각 경우마다 가능한지 검사하는 방법
>   2.  유망한 경우에 대해서만 재귀함수를 호출하는 방법

- 특정 위치(노드)의 가능 여부를 판단할 필요가 있다.
  1. 같은 행에 있는지 체크 : x1 == x2 / 같은 열에 있는지 체크 : y1 == y2
  2. 대각선에 있는지 체크 : abs(x1-x2) == abs(y1-y2)

## 백트래킹의 기본 형태

```js
function recursive(){
    if 종료 조건을 만족한다면 {
        처리;
    }
    for 자식 노드를 하나씩 확인하며 {
        if 임의의 조건을 만족한다면 {
            자식 노드 방문 처리;
            재귀 함수 recursive() 호출;
            자식 노드 방문 처리 해제;
        }
    }
}
```

- 루트 노드에서 자식 노드로 내려간다.
