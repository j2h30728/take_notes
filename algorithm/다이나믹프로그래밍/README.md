# 다이나믹 프로그래밍

- 통상적으로 메모리를 더 사용하여 시간 복잡도를 개선할 때 많이 사용된다.
- 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적요하면 효과적이다.
- 다이나믹 프로그래밍 문제를 해결하기 위해 점화식을 찾는 것이 핵심적인 과정이다.

## 사용조건

다이나믹 프로그래밍은 일반적으로 아래의 두 조건을 만족할 때 사용할 수 있다.

1. 최적 부분 구조 (optimal substructure)
2. 반복되는 부분 문제 (overlapping sub-problem)

### 1. 최적 부분 구조 (optimal substructure)

큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.

#### 점화식과 최적 부분 구조

##### 점화식

인접한 항으로 현재 값을 결정하는 관계식을 의미

- 일반적으로 최적 부분 구조를 만족한다는 특징을 가짐.

> 예시) 피보나치 수열 : [1,1,2,3,5,8,13,21,34,55,89,...]
>
> - 점화식 : \( a*n = a*{n-1} + a\_{n-2}, \quad a_1 = 1, \quad a_2 = 1 \)

###### 점화식의 구성요소

1. 초기항
2. 인접한 항의 관계

- 점화식은 [재귀 함수]로 표현할 수 있다.
- 재귀 함수는 [종료 조건]이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.

점화식을 재귀 함수 코드로 구현

1. 점화식의 초기항은 종료 종료 조건과 같은 역할을 수행한다.
2. 점화식의 내용은 f(x)의 반환 값에 들어간다.

```js
// 피보나치 함수(Fibonacci Function)을 재귀함수로 구현
function fibo(x) {
  //   종료 조건 (없으면 무한루프)
  if (x === 1 || x == 2) {
    return 1;
  }
  // 실질적인 점화식
  return fibo(x - 1) + fibo(x - 2);
}
console.log(fibo(4));
```

피보나치 수열의 점화식을 그대로 재귀함수로 구현한다면?
=> 중복되는 부분 문제가 발생한다. (이미 구한 값을 불필요하게 반복 계산함)

### 2. 반복되는 부분 문제 (overlapping sub-problem)

동일한 작은 문제를 반복적으로 해결해야 한다. (이미 해결한 문제를 또 해결해야 한다.)

```js
// 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = new Array(100).fill(0);

// 피보나치 함수(Fibonacci Function)을 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
function fibo(x) {
  //   종료 조건 (없으면 무한루프)
  if (x === 1 || x == 2) {
    return 1;
  }
  // 한 번 해결한 문제는 여러번 해결하지 않도록
  // 이미 계산한 적있는 문제라면 그대로 반환
  if (d[x] != 0) {
    return d[x];
  }

  // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
  // 실질적인 점화식 부분
  d[x] = fibo(x - 1) + fibo(x - 2);
  return d[x];
}
console.log(fibo(99));
```

## 일반 형태

다이나믹 프로그래밍(재귀 함수)의 대표적인 코드 형식

```js
function dp() {
  // 1. 종료 조건
  // 2. 이미 해결한 문제라면, 정답을 그대로 반환
  // 3. 점화식에 따라 정답 계산
}
```

## 문제 해결 과정

문제 해결 접근 순서

1. 문제 이해
2. 점화식 찾아내기 (핵심)
3. 구현 방식 (상향식/하향식) 결정
4. 점화식을 실제 코드로 구현

### 문제 접근 방법

#### 1. 상향식

반복문을 이용해 초기 항부터 계산

#### 2. 하향식

재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식

- 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라 함.
- 재귀일 경우, 오버플로우 스택이 발생할 수도 있음.

#### 예시 - 피보나치 수열

##### 1. 상향식

```js
// 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = new Array(100).fill(0);
// 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1;
d[2] = 1;
n = 99;
// 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for (let i = 3; i <= n; i++) {
  d[i] = d[i - 1] + d[i - 2];
}
console.log(d[n]);
```

##### 2. 하향식

```js
// 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = new Array(100).fill(0);
// 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
function fibo(x) {
  // 종료 조건(1 혹은 2일 때 1을 반환)
  if (x == 1 || x == 2) {
    return 1;
  }
  // 이미 계산한 적 있는 문제라면 그대로 반환
  if (d[x] != 0) {
    return d[x];
  }
  // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
  d[x] = fibo(x - 1) + fibo(x - 2);
  return d[x];
}
console.log(fibo(99));
```
